# 线性表的类型定义

## 定义：

​	线性表是n个数据元素的有序序列

## 特点：

1. 存在唯一的一个被称为"第一个"的数据元素
2. 存在唯一的一个被称为"最后一个"的数据元素
3. 除第一个之外，集合中的每个数据元素均只有一个前驱
4. 除最后一个之外，集合中的每个数据元素均只有一个后继    

# 线性表的顺序表示和实现

## 定义：

​	线性表的顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素，逻辑关系上相邻的两个元素，物理地址上也相邻。

## 存储位置：

​	一般来说，线性表的第$i$个数据元素$${a}_i$$的存储位置为
$$
LOC({a}_i)=LOC({a}_1)+(i-1)*l
$$
​	公式中$LOC({a}_1)$是线性表的第一个数据元素$a_i$的存储位置，通常被称作线性表的起始位置和基地址。

​	线性表的这种机内表示称做线性表的顺序结构或顺序映像，通常，称这种存储结构的线性表为顺序表。它的特点是，为表中相邻的元素$$a_i$$和$${a}_i+_1$$赋以相邻的存储位置$$LOC({a}_i)$$和$$LOC(a{_i+_1})$$ 。

```c
//------线性表的动态分配顺序存储结构------------
#define LIST_INIT_SIZE 100 //线性表存储空间的初始化分配量
#define LISTINCREMENT  10  //线性表存储空间的分配增量
typedef struct {
    ElemType *elem;        //存储空间基址
  	int length;			  //当前长度
  	int listsize;		  //当前分配的存储容量(以sizeof(ElemType)为单位)
}Sqlist;
```

​	在上述定义中，数据指针elem指示线性表的基地址，length指示线性表的当前长度。顺序表的初始化操作就是为顺序表分配一个预定义大小的数组空间，并将线性表的当前长度设为"0"。listsize指示顺序表当前分配的存储空间大小。一旦因插入元素而空间不足时，可进行再分配，即为顺序表增加一个大小为存储LISTINCREMENT的数据元素的空间。

```c
Status InitList_Sq(SqList &L) {
    //构造一个空的线性表。
  	L.elem = (ElemType *)malloc(LIST_INIT_SIZE *sizeof(ElemType));
  	if(!L.elem)exit(OVERFLOW);//存储分配失败
  	L.length = 0;			//空表长度为0
  	L.listsize = LIST_INIT_SIZE;  //初始存储容量
  	return OK;
}
```

​	线性表的插入操作是指的是在线性表的第$i-1$个数据元素和第$i$个数据元素之间插入一个新的数据元素，就是要长度为$n$的线性表
$$
(a_1,...,a_{i-1},a_i,...,a_n)
$$
变成长度为$n+1$的线性表
$$
(a_1,...,a_{i-1},b,a_i,...,a_n)
$$
数据元素$a_{i-1}$和$a_i$之间的逻辑关系发生了变化，

​	一般情况下，在第$i$(1<=$i$<=$n$)个元素之前插入一个元素时，需将第$n$至第$i$共($n-i+1$)个元素向后移动一个位置。

```c
Status ListInsert_Sq(SqList &L, int i, ElemType e) {
    //在顺序线性表L中第i个位置之前插入新的元素e
    //i的合法值为1<=i<=ListLength_Sq(L)+1
  	if(i < 1 || i > L.length + 1) return ERROR;//i值不合法
  	if(L.length >= L.listsize) { //当前存储空间已满，增加分配
        newbase = (ElemType *)realloc(L.elem, (L.listsize + LISTINCREMENT) * sizeof(ElemType));
      	if(!newbase)exit(OVERFLOW);//存储分配失败
      	L.elem = newbase;
      	L.listsieze += LISTINCREMENT;
    }	
  	q = &(L.elem[i-1]);
  	for(p = &(L.elem[L.length - 1]); p >= q; --p)
      	*(p+1) = *p;// 插入位置及之后的元素右移
  	*q = e; //插入e
  	++L.length;//表长增1
  	return OK;
}
```

​	线性表的删除操作是使长度为$n$的线性表
$$
(a_1,...,a_{i-1},a_i,a_{i+1},...,a_n)
$$
变成长度为$n-1$的线性表
$$
(a_1,...,a_{i-1},a_{i+1},...,a_n)
$$
数据元素$a_{i-1}$,$a_i$,$a_{i+1}$之间的逻辑关系发生了变化，为了在存储结构上反映这个变化，同样需要移动元素。

​	一般情况下，删除第$i$($1<= i <= n$)个元素时需将从第$i+1$至第$n$(共$n-i$)个元素依次向前移动一个位置。

```c
Status ListDelete_Sq(SqList &L, int i, ElemType &e){
	//在顺序线性表L中删除第i个元素，并用e返回其值
  	//i的合法值为1<=i<=ListLength_Sq(L)
  	if((i < 1)||(i > L.length)) return ERROR; //i不合法
  	p = &(L.elem[i -1]);//p为被删除元素的位置
  	e = *p; //被删除元素的值赋给e
  	q = L.elem + L.length - 1; //表尾元素的位置
  	for(++ p; p <= q; ++p) 
      	*(p - 1) = *p; //被删除元素之后的元素后移
  	--L.length;  //表长减1
  	return OK;
}
```

​	从以上两个算法中可见，当在顺序存储结构的线性表中某个位置上插入或删除一个数据元素时，其时间主要消耗在移动元素上，而移动元素的个数取决于插入或删除元素的位置。

​	假设$p_i$是在$i$个元素之前插入一个元素的概率，则在长度为$n$的线性表中插入一个元素时所需要移动元素次数的期望值(平均次数)为
$$
E_{is}=\sum_{i=1}^{n+1}{p_i}(n-i+1)
$$
​	假设$q_i$是删除第$i$个元素的概率，则在长度为$n$的线性表中删除一个元素时所需移动元素次数的期望值(平均次数)为
$$
E_{dl}=\sum_{i=1}^n{q_i}(n-i)
$$
​	不失一般性，我们可以假设在线性表的任何位置上插入或者删除元素都是等概率的，即
$$
p_i=\frac 1 {n+1},q_i=\frac 1 n
$$
​	则两个公式可以简化为
$$
E_{is}=\frac 1 {n+1} \sum_{i=1}^{n+1}(n-i+1)=\frac n 2
$$

$$
E_{dl}=\frac 1 n \sum_{i=1}^n (n-i)=\frac {n-1} 2
$$

​	由此可见，在顺序存储结构的线性表中插入或者删除一个数据元素，平均约移动表中的一半元素。若表长为$n$,则算法ListInsert_Sq和ListDelete_Sq的时间复杂度为$O(n)$。

# 线性表的链式表示和实现

​	线性表的顺序存储结构的特点是逻辑关系上相邻的两个元素在物理地址上也相邻，因此可以随机存取表中任一元素，它的存储位置可用一个简单、直观的公式来表示。然而，从另一方面来讲，这个特点也铸成了这种存储结构的弱点：在插入或者删除的时候，需要移动大量的数据元素。线性表的另一种存储结构：链式存储结构。由于它不要求在逻辑上相邻的元素的物理位置上也相邻，因此它没有顺序结构所具有的弱点，但是同时也失去了顺序表可随机存取的优点。

## 线性链表

​	线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的）。因此，为了表示每个数据元素$a_i$与其直接后继数据元素$a_{i+1}$之间的逻辑关系，对数据元素$a_i$来说，除了本身存储的数据信息外，还需要存储一个指示其直接后继的的信息（即直接后继的存储地址）。这两部分信息组成数据元素$a_i$的存储映像，称为结点(node)。它包括两个域：其中存储数据元素信息的域被称为数据域；存储直接后继存储地址的域称为指针域。指针域中存储的信息称作指针或者链。$n$个结点$(a_i(1<=i<=n))$链接成链表，即为线性表
$$
(a_1,a_2,...a_n)
$$
的链式存储结构。又由于此链表的每个结点中只包含一个指针域，故又称线性链表或单链表。

​	线性表的线性链表存储结构中，整个链表的存取必须从头指针开始进行，头指针指示链表中的第一个结点（即第一个数据元素的存储映像）的存储位置。同时，由于最后一个数据元素没有直接后继，则线性链表中最后一个结点的指针为空（null）。

​	用线性链表表示线性表时，数据元素之间的逻辑关系是由结点中的指针指示的。话句话说，指针为数据元素之间的逻辑关系的映像，则逻辑上相邻的两个数据元素其存储的物理位置不要求相邻，由此，这种存储结构为非顺序映像或链式映像。

```c
//----------线性表的单链表存储结构------------
typedef struct LNode{
    ElemType data;
  	struct LNode * next;
}LNode, * LinkList;
```

​	假设L是LinkList型的变量，则L为单链表的头指针，它指向表中第一个结点。若L为空（L=NULL），则所表示的线性表为空表，其长度$n$为0。有时，我们在单链表的第一个结点之前附设一个结点，称之为头结点。头结点的数据域可以不存储任何数据信息，也可以存储如线性表的长度之类的附加信息，头结点的指针域存储指向第一个结点的指针（即第一个元素结点的存储位置）。

​	在线性表的顺序存储结构中，由于逻辑上相邻的两个元素在物理位置上紧邻，则每个元素的存储位置都可以从线性表的起始位置计算得到。而在单链表中，任何两个元素的存储位置之间没有固定的联系。然而，每个元素的存储位置都包含在其直接前驱结点的信息之中。假设$p$是指向线性表中第$i$个数据元素（结点$a_i$）的指针，则p->next是指向第$i+1$个数据元素（结点$a_{i+1}$）的指针。如果$p->data=a_i$,则$p->next->data=a_{i+1}$。所以，在单链表中，取得第$i$数据元素必须从头指针出发寻找，因此，单链表是非随机存储的存储结构。

```c
Status GetElem_L(LinkList L, int i, ElemType &e) {
    //L为带头结点的单链表的头指针
  	//当第i个元素存在时，其值赋值给e并返回OK，否则返回ERROR
  	p = L->next; j = 1;//初始化，p指向第一个结点，j为计数器
  	while(p && j < i) { //顺指针向后查找，直到p指向第i个元素或p为空
        p = p -> next;
      	++j;
    }
  	if(!p || j > i) {
        return ERROR;//第i个元素不存在
    }
  	e = p -> data;
  	return OK;
}
```

​	该算法中的基本操作是比较$j$和$i$并后移指针$p$，while循环体重的语句频度与被查元素在表中的位置有关，若$1<=i<=n$，则频度为$i-1$,否则频度为$n$,因此该算法的时间复杂度为$O(n)$

​	在单链表中的插入一个数据元素$x$,首先要生成一个数据域为$x$的结点，然后插入在单链表中。根据插入操作的逻辑定义，还需要修改结点$a$中的指针域，令其指向结点$x$，而结点$x$中的指针域应指向结点$b$，从而实现3个元素$a,b和x$之间逻辑关系的变化。即为以下语句：
$$
s->next=p->next;p->=s;
$$
​	在单链表中的删除一个数据元素$b$时，为在单链表中实现元素$a,b和c$之间逻辑关系的变化，仅需要修改结点$a$中的指针域即可。即为以下语句：
$$
p->next=p->next->next;
$$

```c
Status ListInsert_L(LinkList &L, int i, ElemType e) {
    //在带头结点的单链线性表L中第i个位置之前插入元素e
  	p = L; j = 0;
  	while(p && j < i - 1) { //寻找第i-1个结点
        p = p -> next;
      	++ j;
    }
  	if(!p || j > i - 1) return ERROR; 
  	s = (LinkList) malloc (sizeof(LNode));
  	s -> data = e;
  	s -> next = p -> next;
  	p -> next = s;
  	return OK;
}
```

```c
Status ListDelete_L(LinkList &L, int i, ElemType &e) {
    //在带头结点的单链线性表L中，删除第i个元素，并由e返回其值
  	p = L; j = 0;
  	while(p ->next && j < i-1) {//寻找第i个结点，并令p指向其前驱
        p = p -> next;
      	++ j;
    }
  	if(!(p -> next)|| j > i-1) return ERROR;
  	q = p -> next;
  	p -> next = q -> next;
  	e = q -> data;
  	free(q);
  	return OK;
}
```

​	由以上两个算法中，我们可以得知，其时间复杂度为$O(n)$,在第$i$个结点之前插入一个新的结点或者删除第$i$个结点，都必须首先找到第$i-1$个结点，也就是需要修改指针的结点。

​	单链表和顺序存储结构不同，它是一种动态结构。整个可用存储空间可为多个链表共同享用，每个链表占用的空间不需要预先分配划定，而是可以由系统应需求即时生成。因此，建立线性表的链式存储结构的过程就是一个动态生成链表的过程。其时间复杂度为$O(n)$，算法如下：

```c
void CreateList_L(LinkList &L, int n) {
    //逆位序输入n个元素的值，建立带表头结点的单链表L
  	L = (LinkList) malloc (sizeof(LNode));
  	L -> next = null; //先建立一个带头结点的单链表
  	for(i = n; i > 0; --i) {
        p = (LinkList) malloc(sizeof(LNode));//生成新的结点
      	scanf(&p -> data); //输入元素值
      	p -> next = L -> next;
      	L -> next = p;
    }
}
```

## 循环链表

​	循环链表是另一种形式的链式存储结构。它的特点是表中最后一个结点的指针域指向头结点，整个链表形成一个环。循环链表的操作和线性链表基本一致，差别仅在于算法中的循环条件不是$p$或者$p->next$是否为空，而是它们是否等于头指针。

## 双向链表

​	在双向链表的结点中有两个指针域，其一指向直接后继，另一指向直接前驱，其存储结构如下：

```c
//----------------------线性表的双向链表的存储结构-------------
typedef struct DuLNode {
  	ElemType data;
  	struct DuLNode * prior;
  	struct DuLNode * next;
} DuLNode, * DuLinkList;
```

​	在双向链表中插入、删除时，需要同时修改两个方向上的指针。其时间复杂都为$O(n)$

```c
Status ListInsert_DuL(DuLinkList &L, int i, ElemType e) {
    //在带头结点的双链循环线性表L中第i个位置之前插入元素e
  	//i的不合法值为1<=i<=表长+1
  	if(!(p = GetElemP_DuL(L, i))) //在L中确定插入位置
    	return ERROR;             //p=NULL 即插入不合法
  	if(!(s = (DuLinkList)malloc(sizeof(DuLNode)))) return ERROR;
  	s -> data = e;
  	s -> prior = p -> prior;
  	p -> prior->next = s;
  	s -> next = p;
  	p -> prior = s;
  	return OK;
}
```

```c
Status ListDelete_DuL(DuLinkList &L, int i, ElemType &e) {
	//删除带头结点的双链循环线性表L的第i个元素，i的合法值为1<=i<=表长
  	if(!(p = GetElemP_DuL(L, i))) //在L中确定第i个元素的位置指针p
      	return ERROR;
  	e = p -> data;
  	p -> prior -> next = p -> next;
  	p -> next -> prior = p -> prior;
  	free(p);
  	return OK;
}
```

# 参考博客及文档

[1]：[数据结构与算法之线性表](http://www.cnblogs.com/wsnb/p/5191518.html)

[2]：[线性表—维基百科](https://zh.wikipedia.org/zh-cn/%E7%BA%BF%E6%80%A7%E8%A1%A8)

[3]：[线性表—百度百科](https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E8%A1%A8/3228081?fr=aladdin)